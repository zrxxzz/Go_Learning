## Go

### 基本特性

#### 变量/常量

- 导入包的内置变量，字母大写开头

- 函数返回类型和变量放在参数列表后面，函数传参先变量后类型、多个相同类型变量可以把类型放最后

  > 可以简化C当中的函数复杂性
  >
  > 例如，`int (*fp)(int a, int b);` 声明了一个函数指针`fp`，这个指针指向的函数接受两个`int`类型的参数并返回一个`int`类型的结果。如果参数之一也是一个函数，声明会变得更加复杂，如 `int (*fp)(int (*ff)(int x, int y), int b)`。这种情况下，理解和编写类型声明变得非常困难。

- 在变量赋值方面，我觉得很有意思，Golang像是pyhton和C这两者（即弱类型与强类型语言）的结合体

  它可以不声明变量类型，像python或js一样 `a:=1` 或`var a=1`(初始化阶段)

  也可以提前声明类型，像C一样`var a int =10`

  ![image-20240324220054979](https://typora-zrx.oss-cn-beijing.aliyuncs.com/img/2024/03/24/20240324-220057.png)

  即（隐式声明/显示声明）

- 函数允许多值返回，接收的时候 := 可以自动识别并赋值，（放在入参列表后面）

  看上去挺有趣的，因为可以提前为返回值进行操作/(赋值)

- 有个很逆天的iota，专门使用在const初始化中，在其之后每多声明一个变量，就会自增一次，甚至不重置的话，会自动赋值

- 你要么直接在声明的时候初始化，选择隐式声明；要么显示声明之后，后续进行初始化。

  不管如何，初始化是必须的


#### 循环

- 没有while 循环，只有for 循环

- 内置下标索引，可以在for的 初始化部分，使用`range`可以自动识别迭代器

  > 默认返回两个值 index , value ，如果只接收了一个，会默认返回index
  >
  > 如果只想接收一个，可以选择使用`_ `替代一个 如`_:value`

  如`for sub:= range nums`  自动取出下标

  如`for i, sub := range nums` 其中的 `i`就会自动获取下标的索引

- 如果 需要遍历的变量本身就像 map 一样存键值对， 那么也可以像上面那样实现多变量提取

#### 数组

- 和之前一样，类型放后面，需要注意的是，`[size]`需要放在类型前面
- 如果不确定长度，可以先用`...`代替，如`nums [...]int`

#### 指针

- 指针和之前的数组一样，虽然类型放在后面，但是`*`放在类型前面
- `nil`就是C中的`NULL`
- 指针指向结构体，不需要和CPP一样，使用`->`，依旧使用`.`来实现访问内部变量

#### 结构体

- 声明时类型放在后面

- 初始化的时候，可以直接使用列表初始化的形式`:=structure {value1, value2}`初始化所有内部变量

  或者自定义，初始化一部分`:=structure{key1:value1,key2:value2}`

#### 切片

> 本身的定义就是 未指定大小的数组，类似于vector

- 初始化可以使用`make`函数（使用make可以初始化长度、容量）

- 可以根据下标生成一个新的切片副本（很像python）

  如：`a := arr[0:2]`

- ！！！居然可以格式化输出一整个容器，厉害的

  如`fmt.Printf("%v",a)`会自动遍历并输出整个容器内容

  甚至可以 `%#v`带类型输出，`%+v`带字段输出（结构体）

  ![image-20240329160015219](https://typora-zrx.oss-cn-beijing.aliyuncs.com/img/2024/03/29/20240329-160020.png)

  应用到的底层原理是反射机制，原理就像CPP动态绑定一样，在运行时能通过反射API检测对象的类型和值

- 通过 append 来实现尾部添加、copy 实现切片拷贝

  两者返回的都是新的切片，因此并不是像CPP那样调用对象的方法，而是直接调用函数，返回值是一个新的切片，函数不会修改原切片（除非用指针），通过赋值修改

  ![image-20240329193408177](https://typora-zrx.oss-cn-beijing.aliyuncs.com/img/2024/03/29/20240329-193411.png)

#### Map

